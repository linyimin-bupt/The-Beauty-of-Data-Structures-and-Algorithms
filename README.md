# 数据结构与算法之美

## 链表

### 单链表的实现

[单链表的实现](src/linked-list/singly-linked-list/singly-linked-list.ts)

### 基于单链表的最近最少用策略(LRU)的实现

[lru的实现](src/linked-list/least-recently-used/lru.ts): 维护一个有序的单链表,越靠近尾部的结点是越早之前访问的,当有一个新的数据被访问时,从链表的头部开始遍历链表:

1. 如果此数据之前已经被缓存在链表中,遍历得到这个数据对应的结点,将其从原来的位置删除,然后插入到链表的头部
2. 如此数据不存在链表中:
   1. 此时缓存未满,则直接将数据插入到链表的头部
   2. 此时缓存已满,先删除链表的尾节点,然后再将新的数据结点插入链表的头部.

### 常用的链表操作

#### [使用快慢指针查找链表的中间结点](src/linked-list/related-problems/intermediate-node.ts)

基本思想:

1. 设置两个指针
  - slow指针: 每次移动一步
  - fast指针: 每次移动两步

2. 若结点的个数为偶数, 当fast指针无法继续移动时,慢指针刚好指向链表的中间结点
3. 若结点的个数为奇数, 当fast指针无法继续移动时,慢指针刚好指向中间结点的前一个结点

#### [链表的翻转](src/linked-list/related-problems/list-reverse.ts)

基本思想:

1. 设置3个指针p,q,r,将p指向链表的开头,q指向第二个结点
2. 将头结点p与第二个结点q断开
3. 循环
   1. 将q结点的当前下一个结点设为r
   2. 将q指向前一个结点p
   3. p, q, r一次向后移动一个结点
4. 将尾节点设为头结点

#### [链表中环的检测](src/linked-list/related-problems/cycling-list.ts)

检测思路:

1. 设置快慢指针,慢指针每次走一步,快指针每次走两步
2. 若快慢指针相遇,则说明链表中存在环
3. 若快指针到达链表尾部且没有与慢指针相遇,则说明链表中不存在环

#### [查找有环链表的入口节点](src/linked-list/related-problems/cycling-list.ts)

不妨设,快指针fast和慢指针slow在头结点出发,相遇于C结点,在这个过程中慢指针slow走了N步,则快指针fast走了2N步

慢指针slow: A ---> B ---> C (共走了N步)
快指针fast: A ---> B ---> C (共走了2N步)

==> 由上可知快指针比慢指针多走了N步,所以慢指针slow再走N步还会回到C节点.

此时若再设一个慢指针slow1,从头结点开始,经过N步之后也会到达C结点

slow:  C ---> B ---> C
slow1: A ---> B ---> C

===> 两个慢指针若想在C点相遇,必要条件是: 在B点(入环口)相遇,然后携手走完B ---> C的路程

#### [两个有序链表的合并](src/linked-list/related-problems/list-merge.ts)

基本思想: 需要额外的空间存储合并之后的链表

#### 删除链表的第n个节点

基本思想:

遍历链表,使用count记录p.next,当count == n时, p即为要删除结点的前驱结点